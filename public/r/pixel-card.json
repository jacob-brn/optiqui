{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixel-card",
  "type": "registry:component",
  "title": "Pixel Card",
  "description": "Card that reveals pixelized background on hover",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "registry/ui/PixelCard.tsx",
      "content": "\"use client\";\r\nimport type React from \"react\";\r\nimport { useState } from \"react\";\r\nimport { motion } from \"motion/react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface PixelCanvasProps {\r\n  gap?: number;\r\n  speed?: number;\r\n  colors?: string;\r\n  noFocus?: boolean;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n}\r\n\r\ninterface CardProps {\r\n  icon: React.ReactNode;\r\n  text: string;\r\n  canvasProps?: PixelCanvasProps;\r\n  className?: string;\r\n}\r\n\r\ndeclare global {\r\n  namespace JSX {\r\n    interface IntrinsicElements {\r\n      \"pixel-canvas\": React.DetailedHTMLProps<\r\n        React.HTMLAttributes<HTMLElement>,\r\n        HTMLElement\r\n      >;\r\n    }\r\n  }\r\n}\r\n\r\nconst PixelCanvas = ({\r\n  gap = 5,\r\n  speed = 35,\r\n  colors = \"#f8fafc,#f1f5f9,#cbd5e1\",\r\n  noFocus = false,\r\n  minSize = 0.5,\r\n  maxSize = 2,\r\n  className,\r\n}: {\r\n  gap?: number;\r\n  speed?: number;\r\n  colors?: string;\r\n  noFocus?: boolean;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  className?: string;\r\n}) => {\r\n  return (\r\n    <pixel-canvas\r\n      data-gap={gap}\r\n      data-speed={speed}\r\n      data-colors={colors}\r\n      data-minSize={minSize}\r\n      data-maxSize={maxSize}\r\n      {...(noFocus ? { \"data-no-focus\": \"\" } : {})}\r\n      className={cn(\"absolute inset-0 size-full w-full max-h-full\", className)}\r\n    />\r\n  );\r\n};\r\n\r\nconst PixelCard = ({ text, icon, canvasProps = {}, className }: CardProps) => {\r\n  const [isHovered, setIsHovered] = useState<boolean>(false);\r\n\r\n  return (\r\n    <>\r\n      <motion.div\r\n        className={cn(\r\n          \"max-w-[200px] relative overflow-hidden cursor-pointer select-none\",\r\n          className\r\n        )}\r\n        onMouseEnter={() => setIsHovered(true)}\r\n        onMouseLeave={() => setIsHovered(false)}\r\n        animate={isHovered ? \"hover\" : \"default\"}\r\n        initial=\"default\"\r\n      >\r\n        <motion.div\r\n          className=\"absolute w-full h-full top-0 left-0 inset-0 bg-background z-10\"\r\n          variants={{\r\n            default: { opacity: 0 },\r\n            hover: {\r\n              opacity: [0, 0.1, 0.2, 0.5, 0.3, 0.6, 0.4, 0.6, 0.7, 0.6], // black out effect\r\n              transition: {\r\n                duration: 1,\r\n                delay: 0.3,\r\n                ease: \"easeInOut\",\r\n              },\r\n            },\r\n          }}\r\n        />\r\n\r\n        <motion.div\r\n          className=\"absolute inset-0 w-full h-full flex items-center justify-center\"\r\n          variants={{\r\n            default: {\r\n              opacity: 1,\r\n            },\r\n            hover: {\r\n              opacity: 0,\r\n              transition: {\r\n                duration: 1,\r\n                delay: 0.3,\r\n                ease: \"easeInOut\",\r\n              },\r\n            },\r\n          }}\r\n        >\r\n          {icon}\r\n        </motion.div>\r\n\r\n        <motion.div\r\n          className=\"absolute inset-0 w-full h-full flex items-center justify-center z-20\"\r\n          variants={{\r\n            default: {\r\n              opacity: 0,\r\n              filter: \"blur(3px)\",\r\n              transition: {\r\n                duration: 0.3,\r\n                ease: \"easeInOut\",\r\n              },\r\n            },\r\n            hover: {\r\n              filter: \"blur(0px)\",\r\n              opacity: 1,\r\n              transition: {\r\n                duration: 1,\r\n                delay: 0.6,\r\n                ease: \"easeInOut\",\r\n              },\r\n            },\r\n          }}\r\n        >\r\n          <div className=\"px-6\">\r\n            <p className=\"max-w-xs text-foreground text-sm text-center font-medium text-balance\">\r\n              {text}\r\n            </p>\r\n          </div>\r\n        </motion.div>\r\n        <PixelCanvas {...canvasProps} className=\"w-full h-full\" />\r\n      </motion.div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default PixelCard;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/scripts/pixel.js",
      "content": "class Pixel {\r\n  constructor(\r\n    canvas,\r\n    context,\r\n    x,\r\n    y,\r\n    color,\r\n    speed,\r\n    delay,\r\n    minSize = 0.5,\r\n    maxSize = 2\r\n  ) {\r\n    this.width = canvas.width;\r\n    this.height = canvas.height;\r\n    this.ctx = context;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.color = color;\r\n    this.speed = this.getRandomValue(0.1, 0.9) * speed;\r\n    this.size = 0;\r\n    this.sizeStep = Math.random() * 0.4;\r\n    this.minSize = minSize;\r\n    this.maxSizeInteger = maxSize;\r\n    this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);\r\n    this.delay = delay;\r\n    this.counter = 0;\r\n    this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;\r\n    this.isIdle = false;\r\n    this.isReverse = false;\r\n    this.isShimmer = false;\r\n  }\r\n\r\n  getRandomValue(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n\r\n  draw() {\r\n    const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;\r\n\r\n    this.ctx.fillStyle = this.color;\r\n    this.ctx.fillRect(\r\n      this.x + centerOffset,\r\n      this.y + centerOffset,\r\n      this.size,\r\n      this.size\r\n    );\r\n  }\r\n\r\n  appear() {\r\n    this.isIdle = false;\r\n\r\n    if (this.counter <= this.delay) {\r\n      this.counter += this.counterStep;\r\n      return;\r\n    }\r\n\r\n    if (this.size >= this.maxSize) {\r\n      this.isShimmer = true;\r\n    }\r\n\r\n    if (this.isShimmer) {\r\n      this.shimmer();\r\n    } else {\r\n      this.size += this.sizeStep;\r\n    }\r\n\r\n    this.draw();\r\n  }\r\n\r\n  disappear() {\r\n    this.isShimmer = false;\r\n    this.counter = 0;\r\n\r\n    if (this.size <= 0) {\r\n      this.isIdle = true;\r\n      return;\r\n    } else {\r\n      this.size -= 0.1;\r\n    }\r\n\r\n    this.draw();\r\n  }\r\n\r\n  shimmer() {\r\n    if (this.size >= this.maxSize) {\r\n      this.isReverse = true;\r\n    } else if (this.size <= this.minSize) {\r\n      this.isReverse = false;\r\n    }\r\n\r\n    if (this.isReverse) {\r\n      this.size -= this.speed;\r\n    } else {\r\n      this.size += this.speed;\r\n    }\r\n  }\r\n}\r\n\r\nclass PixelCanvas extends HTMLElement {\r\n  static register(tag = \"pixel-canvas\") {\r\n    if (\"customElements\" in window) {\r\n      customElements.define(tag, this);\r\n    }\r\n  }\r\n\r\n  static css = `\r\n    :host {\r\n      display: grid;\r\n      inline-size: 100%;\r\n      block-size: 100%;\r\n      overflow: hidden;\r\n    }\r\n  `;\r\n\r\n  get colors() {\r\n    return this.dataset.colors?.split(\",\") || [\"#f8fafc\", \"#f1f5f9\", \"#cbd5e1\"];\r\n  }\r\n\r\n  get minSize() {\r\n    return parseFloat(this.dataset.minsize) || 0.5;\r\n  }\r\n\r\n  get maxSize() {\r\n    return parseFloat(this.dataset.maxsize) || 2;\r\n  }\r\n\r\n  get gap() {\r\n    const value = this.dataset.gap || 5;\r\n    const min = 4;\r\n    const max = 50;\r\n\r\n    if (value <= min) {\r\n      return min;\r\n    } else if (value >= max) {\r\n      return max;\r\n    } else {\r\n      return Number.parseInt(value);\r\n    }\r\n  }\r\n\r\n  get speed() {\r\n    const value = this.dataset.speed || 35;\r\n    const min = 0;\r\n    const max = 100;\r\n    const throttle = 0.001;\r\n\r\n    if (value <= min || this.reducedMotion) {\r\n      return min;\r\n    } else if (value >= max) {\r\n      return max * throttle;\r\n    } else {\r\n      return Number.parseInt(value) * throttle;\r\n    }\r\n  }\r\n\r\n  get noFocus() {\r\n    return this.hasAttribute(\"data-no-focus\");\r\n  }\r\n\r\n  connectedCallback() {\r\n    const canvas = document.createElement(\"canvas\");\r\n    const sheet = new CSSStyleSheet();\r\n\r\n    this._parent = this.parentNode;\r\n    this.shadowroot = this.attachShadow({ mode: \"open\" });\r\n\r\n    sheet.replaceSync(PixelCanvas.css);\r\n\r\n    this.shadowroot.adoptedStyleSheets = [sheet];\r\n    this.shadowroot.append(canvas);\r\n    this.canvas = this.shadowroot.querySelector(\"canvas\");\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n    this.timeInterval = 1000 / 60;\r\n    this.timePrevious = performance.now();\r\n    this.reducedMotion = window.matchMedia(\r\n      \"(prefers-reduced-motion: reduce)\"\r\n    ).matches;\r\n\r\n    this.init();\r\n    this.resizeObserver = new ResizeObserver(() => this.init());\r\n    this.resizeObserver.observe(this);\r\n\r\n    if (this.noFocus) {\r\n      // If noFocus is true, start animation immediately\r\n      this.handleAnimation(\"appear\");\r\n    } else {\r\n      // Otherwise, add hover listeners\r\n      this._parent.addEventListener(\"mouseenter\", this);\r\n      this._parent.addEventListener(\"mouseleave\", this);\r\n      this._parent.addEventListener(\"focusin\", this);\r\n      this._parent.addEventListener(\"focusout\", this);\r\n    }\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.resizeObserver.disconnect();\r\n    if (!this.noFocus) {\r\n      this._parent.removeEventListener(\"mouseenter\", this);\r\n      this._parent.removeEventListener(\"mouseleave\", this);\r\n      this._parent.removeEventListener(\"focusin\", this);\r\n      this._parent.removeEventListener(\"focusout\", this);\r\n    }\r\n    cancelAnimationFrame(this.animation);\r\n    delete this._parent;\r\n  }\r\n\r\n  handleEvent(event) {\r\n    if (!this.noFocus) {\r\n      this[event.type](event);\r\n    }\r\n  }\r\n\r\n  mouseenter() {\r\n    this.handleAnimation(\"appear\");\r\n  }\r\n\r\n  mouseleave() {\r\n    this.handleAnimation(\"disappear\");\r\n  }\r\n\r\n  focusin(e) {\r\n    if (e.currentTarget.contains(e.relatedTarget)) return;\r\n    this.handleAnimation(\"appear\");\r\n  }\r\n\r\n  focusout(e) {\r\n    if (e.currentTarget.contains(e.relatedTarget)) return;\r\n    this.handleAnimation(\"disappear\");\r\n  }\r\n\r\n  handleAnimation(name) {\r\n    cancelAnimationFrame(this.animation);\r\n    this.animation = this.animate(name);\r\n  }\r\n\r\n  init() {\r\n    const rect = this.getBoundingClientRect();\r\n    const width = Math.floor(rect.width);\r\n    const height = Math.floor(rect.height);\r\n\r\n    this.pixels = [];\r\n    this.canvas.width = width;\r\n    this.canvas.height = height;\r\n    this.canvas.style.width = `${width}px`;\r\n    this.canvas.style.height = `${height}px`;\r\n    this.createPixels();\r\n  }\r\n\r\n  getDistanceToCanvasCenter(x, y) {\r\n    const dx = x - this.canvas.width / 2;\r\n    const dy = y - this.canvas.height / 2;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    return distance;\r\n  }\r\n\r\n  createPixels() {\r\n    for (let x = 0; x < this.canvas.width; x += this.gap) {\r\n      for (let y = 0; y < this.canvas.height; y += this.gap) {\r\n        const color =\r\n          this.colors[Math.floor(Math.random() * this.colors.length)];\r\n        const delay = this.reducedMotion\r\n          ? 0\r\n          : this.getDistanceToCanvasCenter(x, y);\r\n\r\n        this.pixels.push(\r\n          new Pixel(\r\n            this.canvas,\r\n            this.ctx,\r\n            x,\r\n            y,\r\n            color,\r\n            this.speed,\r\n            delay,\r\n            this.minSize,\r\n            this.maxSize\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  animate(fnName) {\r\n    this.animation = requestAnimationFrame(() => this.animate(fnName));\r\n\r\n    const timeNow = performance.now();\r\n    const timePassed = timeNow - this.timePrevious;\r\n\r\n    if (timePassed < this.timeInterval) return;\r\n\r\n    this.timePrevious = timeNow - (timePassed % this.timeInterval);\r\n\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    for (let i = 0; i < this.pixels.length; i++) {\r\n      if (this.noFocus && this.pixels[i].isIdle) {\r\n        // Only reset idle pixels if noFocus is true\r\n        this.pixels[i].isIdle = false;\r\n        this.pixels[i].size = this.pixels[i].maxSize;\r\n      }\r\n      this.pixels[i][fnName]();\r\n    }\r\n\r\n    // Only cancel animation if all pixels are idle and noFocus is false\r\n    if (!this.noFocus && this.pixels.every((pixel) => pixel.isIdle)) {\r\n      cancelAnimationFrame(this.animation);\r\n    }\r\n  }\r\n}\r\n\r\n// Register the custom element\r\nPixelCanvas.register();\r\n",
      "type": "registry:file",
      "target": "~/public/scripts/pixel.js"
    }
  ]
}